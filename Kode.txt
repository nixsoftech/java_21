import re
import time
import os
import random
import logging
import psutil
import argparse
from datetime import datetime, timedelta
from pywinauto.application import Application
from pywinauto.keyboard import send_keys
from pywinauto.timings import TimeoutError
from pywinauto import timings

# ---------------- Logging Setup ----------------
script_name = os.path.splitext(os.path.basename(__file__))[0]
log_dir = os.path.join(os.getcwd(), "logs")
os.makedirs(log_dir, exist_ok=True)

timestamp = datetime.now().strftime("%Y-%m-%d_%H%M%S")
log_file = os.path.join(log_dir, f"{script_name}_{timestamp}.log")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler(log_file, mode="w", encoding="utf-8"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

TIME_RE = re.compile(r"^\d{2}:\d{2}:\d{2}$")


# ---------------- Helper Functions (same as your version) ----------------
# (safe_type, safe_select, safe_click, handle_popup, handle_post_login_popups,
# click_rms_configuration_and_peak_margin, grid helpers, etc. — unchanged)


# ------------------- Peak Margin Add (Modified for CLI Override) -------------------
def handle_peak_margin_add(app, main_win, override_start=None, override_end=None):
    """
    Adds a new Peak Margin row.
    If override_start and override_end are provided, use them instead of calculating automatically.
    """
    logger.info("Looking for Peak Margin panel inside main window...")
    peak_margin_win = main_win.child_window(title="Peak Margin", control_type="Window")
    peak_margin_win.wait("visible", timeout=10)

    # 1) Read existing grid and infer metadata
    rows_before, cols_before, time_cols_before = get_grid_rows_and_meta(peak_margin_win)
    logger.info(f"Found {len(rows_before)} existing rows, cols={cols_before}, time_cols={time_cols_before}")

    # Determine start & end times
    if override_start and override_end:
        start_time = override_start
        end_time = override_end
        logger.info(f"Using manually overridden Start={start_time}, End={end_time}")
    else:
        # Same logic as before (automatic calculation)
        last_end_dt = None
        if rows_before:
            last_row_values = rows_before[-1][1]
            times_in_row = [v for v in last_row_values if TIME_RE.match(v)]
            if len(times_in_row) >= 2:
                last_end_str = times_in_row[1]
            elif len(times_in_row) == 1:
                last_end_str = times_in_row[0]
            else:
                last_end_str = None

            if last_end_str:
                today = datetime.now().date()
                try:
                    last_end_dt = datetime.combine(today, datetime.strptime(last_end_str, "%H:%M:%S").time())
                    logger.info(f"Detected last end time from grid: {last_end_str}")
                except Exception as e:
                    logger.warning(f"Failed parse last_end_str='{last_end_str}': {e}")
                    last_end_dt = None
        else:
            logger.info("No rows found before Add; will use default start time base.")

        now = datetime.now()
        if last_end_dt:
            base_dt = last_end_dt + timedelta(minutes=1)
            base_dt += timedelta(minutes=random.randint(0, 3))
            start_dt = base_dt
        else:
            start_dt = datetime.combine(now.date(), datetime.min.time()) + timedelta(hours=17, minutes=random.randint(0, 59))

        end_dt = start_dt + timedelta(minutes=10)
        start_time = start_dt.strftime("%H:%M:%S")
        end_time = end_dt.strftime("%H:%M:%S")
        logger.info(f"Auto-calculated Start={start_time}, End={end_time}")

    # (Rest of handle_peak_margin_add is unchanged — click Add, fill cells, save)
    # ...


# ------------------- Workflow Runner -------------------
def run_workflow_for_user(username, password, is_rash1=False, start_time_value=None, override_start=None, override_end=None):
    close_rms_if_running()
    logger.info(f"Starting RMS for user: {username}")
    app = Application(backend="uia").start(
        r"D:\Program Files (x86)\NCCL Ltd\RMSSetup\RMS FE.exe"
    )
    main_win = login_user(app, username, password)
    click_rms_configuration_and_peak_margin(main_win)

    if not is_rash1:
        start_time = handle_peak_margin_add(app, main_win, override_start, override_end)
    else:
        if not start_time_value:
            raise ValueError("start_time_value is required for rash1 run")
        handle_peak_margin_reject_for_rash1(app, main_win, start_time_value)
        start_time = None

    safe_click(main_win, title="Exit", control_type="MenuItem")
    handle_popup(app, auto_id_to_click="6", timeout=10)
    logger.info(f"Workflow completed for user: {username}")
    return start_time


# ------------------- Main -------------------
def main():
    parser = argparse.ArgumentParser(description="Run RMS Automation Workflow")
    parser.add_argument("--starttime", help="Override start time (HH:MM:SS)", required=False)
    parser.add_argument("--endtime", help="Override end time (HH:MM:SS)", required=False)
    args = parser.parse_args()

    if args.starttime and not TIME_RE.match(args.starttime):
        raise ValueError("Invalid format for --starttime. Use HH:MM:SS")
    if args.endtime and not TIME_RE.match(args.endtime):
        raise ValueError("Invalid format for --endtime. Use HH:MM:SS")

    try:
        start_time_value = run_workflow_for_user("QA1", "change@1212", is_rash1=False,
                                                override_start=args.starttime, override_end=args.endtime)
        run_workflow_for_user("rash1", "change@1212", is_rash1=True, start_time_value=start_time_value)
        logger.info("Automation script completed successfully for both users.")
    except Exception as e:
        logger.exception(f"Automation failed: {e}")


if __name__ == "__main__":
    main()
