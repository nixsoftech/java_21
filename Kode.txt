def handle_peak_margin(app, main_win):
    logger.info("Looking for Peak Margin panel inside main window...")
    peak_margin_win = main_win.child_window(title="Peak Margin", control_type="Window")
    peak_margin_win.wait("visible", timeout=10)

    logger.info("Peak Margin panel detected. Clicking Add...")
    safe_click(peak_margin_win, title="Add", control_type="Button")
    time.sleep(1)

    # ðŸ”Ž --- CAPTURE ALL TABLES AND ROWS ---
    tables = peak_margin_win.descendants(control_type="Table")
    if not tables:
        raise RuntimeError("No tables found in Peak Margin window after clicking Add")

    logger.info(f"Found {len(tables)} tables inside Peak Margin window")
    for t_index, tbl in enumerate(tables):
        cells = tbl.descendants(control_type="DataItem")
        logger.info(f"Table {t_index}: {len(cells)} data cells")
        for c_index, cell in enumerate(cells):
            logger.info(f"  [Table {t_index} | Cell {c_index}] "
                        f"Name='{cell.element_info.name}', "
                        f"ControlType='{cell.element_info.control_type}', "
                        f"Class='{cell.element_info.class_name}', "
                        f"AutomationId='{cell.element_info.automation_id}'")

    # --- Choose first table for now (you can later filter by name) ---
    grid = tables[0]
    grid.wait("exists ready", timeout=10)

    all_data_items = grid.descendants(control_type="DataItem")
    if not all_data_items:
        raise RuntimeError("No data cells found in selected table after clicking Add")

    logger.info(f"Detected {len(all_data_items)} data cells in table[0].")
    columns_per_row = 4  # assumption
    rows = [all_data_items[i:i + columns_per_row] for i in range(0, len(all_data_items), columns_per_row)]
    last_row_cells = rows[-1]
    logger.info(f"Selected last row with {len(last_row_cells)} cells.")

    # ðŸ”Ž --- DUMP ONLY ROW-RELATED INFO ---
    try:
        row_dump = []
        for idx, cell in enumerate(last_row_cells):
            row_dump.append({
                "index": idx,
                "name": cell.element_info.name,
                "control_type": cell.element_info.control_type,
                "class_name": cell.element_info.class_name,
                "automation_id": cell.element_info.automation_id,
                "is_enabled": cell.is_enabled(),
                "is_visible": cell.is_visible(),
            })
        logger.info(f"Row dump after Add:\n{row_dump}")
    except Exception as dump_err:
        logger.warning(f"Could not dump last row info: {dump_err}")

    now = datetime.now()
    start_time = (datetime.combine(now.date(), datetime.min.time()) +
                  timedelta(hours=17, minutes=random.randint(0, 59))).strftime("%H:%M:%S")
    end_time = (datetime.strptime(start_time, "%H:%M:%S") + timedelta(minutes=10)).strftime("%H:%M:%S")

    logger.info(f"Filling new row with Start={start_time}, End={end_time} (Executable/Flag skipped)")

    def wait_for_edit_control(timeout=3):
        timings.wait_until(
            timeout,
            0.2,
            lambda: any("WindowsForms10.EDIT" in e.class_name for e in find_elements())
        )
        elements = [e for e in find_elements() if "WindowsForms10.EDIT" in e.class_name]
        return elements[0] if elements else None

    def set_cell_value(cell, value, max_attempts=3):
        for attempt in range(1, max_attempts + 1):
            try:
                cell.click_input(double=True)
                logger.info(f"Clicked cell, waiting for edit control (attempt {attempt})")
                edit_elem = wait_for_edit_control(timeout=3)
                if not edit_elem:
                    raise TimeoutError("Edit control did not appear")

                edit = app.window(handle=edit_elem.handle)
                edit.set_focus()
                time.sleep(0.1)
                edit.type_keys("^a{BACKSPACE}", set_foreground=True)
                time.sleep(0.1)
                edit.type_keys(value, with_spaces=True, set_foreground=True)
                time.sleep(0.2)

                typed_value = edit.window_text().strip()
                if typed_value == value:
                    logger.info(f"Successfully set cell value '{value}' on attempt {attempt}")
                    send_keys("{TAB}")
                    time.sleep(0.4)
                    return
                else:
                    logger.warning(f"Attempt {attempt}: typed '{value}' but read back '{typed_value}', retrying...")
            except Exception as e:
                logger.warning(f"Attempt {attempt} failed: {e}")
                time.sleep(0.5)

        raise TimeoutError(f"Failed to set and verify value '{value}' after {max_attempts} attempts")

    try:
        set_cell_value(last_row_cells[0], start_time)  # Start Time
        set_cell_value(last_row_cells[1], end_time)    # End Time
    except Exception as e:
        logger.error(f"Row filling failed: {e}")
        raise

    safe_click(peak_margin_win, title="Save", control_type="Button")
    time.sleep(2)
    logger.info("Row filled (Start & End) and saved successfully.")
