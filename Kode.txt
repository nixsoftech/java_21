import re
import time
import os
import random
import logging
import psutil
import argparse
from datetime import datetime, timedelta
from pywinauto.application import Application
from pywinauto.keyboard import send_keys
from pywinauto.timings import TimeoutError
from pywinauto import timings
from pywinauto.mouse import move, double_click

# ---------------- Logging Setup ----------------
script_name = os.path.splitext(os.path.basename(__file__))[0]
log_dir = os.path.join(os.getcwd(), "logs")
os.makedirs(log_dir, exist_ok=True)

timestamp = datetime.now().strftime("%Y-%m-%d_%H%M%S")
log_file = os.path.join(log_dir, f"{script_name}_{timestamp}.log")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler(log_file, mode="w", encoding="utf-8"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

TIME_RE = re.compile(r"^\d{2}:\d{2}:\d{2}$")

# ---------------- Helper Functions ----------------
def safe_type(window, auto_id, control_type, text, retries=5, delay=2):
    for attempt in range(1, retries + 1):
        try:
            ctrl = window.child_window(auto_id=auto_id, control_type=control_type)
            ctrl.wait("enabled", timeout=5).type_keys(text, with_spaces=True)
            logger.info(f"Typed '{text}' into {auto_id} (attempt {attempt})")
            return True
        except Exception as e:
            logger.warning(f"Attempt {attempt} failed for {auto_id}: {e}")
            time.sleep(delay)
    raise TimeoutError(f"Failed to type into {auto_id} after {retries} attempts")


def safe_select(window, auto_id, control_type, value, retries=5, delay=2):
    for attempt in range(1, retries + 1):
        try:
            ctrl = window.child_window(auto_id=auto_id, control_type=control_type)
            ctrl.wait("enabled", timeout=5).select(value)
            logger.info(f"Selected '{value}' in {auto_id} (attempt {attempt})")
            return True
        except Exception as e:
            logger.warning(f"Attempt {attempt} failed for {auto_id}: {e}")
            time.sleep(delay)
    raise TimeoutError(f"Failed to select {value} in {auto_id} after {retries} attempts")


def safe_click(window, auto_id=None, title=None, control_type="Button", retries=5, delay=2):
    for attempt in range(1, retries + 1):
        try:
            ctrl = window.child_window(auto_id=auto_id, title=title, control_type=control_type)
            ctrl.wait("enabled", timeout=5).click_input()
            time.sleep(0.5)
            logger.info(f"Clicked {auto_id or title} (attempt {attempt})")
            return True
        except Exception as e:
            logger.warning(f"Attempt {attempt} failed for {auto_id or title}: {e}")
            time.sleep(delay)
    raise TimeoutError(f"Failed to click {auto_id or title} after {retries} attempts")


def handle_popup(app, expected_substring=None, auto_id_to_click=None, timeout=15):
    try:
        popup = app.window(title_re=".*")
        popup.wait("visible", timeout=timeout)
        popup_text = popup.window_text().strip()
        logger.info(f"Popup detected: '{popup_text}'")

        if expected_substring and expected_substring.lower() not in popup_text.lower():
            logger.warning(f"Popup text mismatch. Expected '{expected_substring}' but got '{popup_text}'")

        if auto_id_to_click:
            try:
                btn = popup.child_window(auto_id=auto_id_to_click, control_type="Button")
                btn.wait("enabled", timeout=5).click_input()
                logger.info(f"Clicked popup button with AutomationId={auto_id_to_click}")
            except Exception as e:
                logger.error(f"Failed to click popup button with AutomationId={auto_id_to_click}: {e}")
        return True

    except TimeoutError:
        logger.info(f"No popup appeared within {timeout}s.")
        return False


def handle_post_login_popups(app, main_win, timeout=20):
    try:
        logger.info("Waiting for 'BMS OpmsEngine Got abandoned' popup...")
        popup1 = main_win.child_window(title="Risk Management System", control_type="Window")
        popup1.wait("visible", timeout=timeout)
        safe_click(popup1, auto_id="2", control_type="Button")
        logger.info("[Popup1] Clicked OK")

        time.sleep(2)
        logger.info("Waiting for 'Do you want to close RMS' popup...")
        popup2 = main_win.child_window(title="Risk Management System", control_type="Window")
        popup2.wait("visible", timeout=timeout)
        safe_click(popup2, auto_id="7", control_type="Button")
        logger.info("[Popup2] Clicked NO")

    except TimeoutError:
        logger.warning("No post-login popups appeared within timeout.")


def click_rms_configuration_and_peak_margin(main_win):
    try:
        logger.info("Navigating to RMS Configuration -> Peak Margin via menu_select...")
        main_win.menu_select("RMS Configuration->Peak Margin")
        logger.info("Successfully opened Peak Margin window.")
    except Exception:
        logger.warning("menu_select failed, using fallback clicks...")
        safe_click(main_win, title="RMS Configuration", control_type="MenuItem")
        time.sleep(1)
        safe_click(main_win, title="Peak Margin", control_type="MenuItem")

# ------------------- Grid helpers (same as before) -------------------
# _get_cell_text, _infer_columns_per_row, get_grid_rows_and_meta, dump_peak_margin_grid
# ... (unchanged from your code)

# ------------------- Peak Margin Add (MODIFIED ONLY HERE) -------------------
def handle_peak_margin_add(app, main_win, override_start=None, override_end=None):
    """
    Adds a new Peak Margin row such that the new row's Start Time > last row's End Time.
    If override_start & override_end are given, use them directly.
    """
    logger.info("Looking for Peak Margin panel inside main window...")
    peak_margin_win = main_win.child_window(title="Peak Margin", control_type="Window")
    peak_margin_win.wait("visible", timeout=10)

    rows_before, cols_before, time_cols_before = get_grid_rows_and_meta(peak_margin_win)
    logger.info(f"Found {len(rows_before)} existing rows, cols={cols_before}, time_cols={time_cols_before}")

    if override_start and override_end:
        start_time = override_start
        end_time = override_end
        logger.info(f"Using overridden Start={start_time}, End={end_time}")
    else:
        # --- Your original calculation logic stays as-is ---
        last_end_dt = None
        if rows_before:
            last_row_values = rows_before[-1][1]
            times_in_row = [v for v in last_row_values if TIME_RE.match(v)]
            if len(times_in_row) >= 2:
                last_end_str = times_in_row[1]
            elif len(times_in_row) == 1:
                last_end_str = times_in_row[0]
            else:
                last_end_str = None

            if last_end_str:
                today = datetime.now().date()
                try:
                    last_end_dt = datetime.combine(today, datetime.strptime(last_end_str, "%H:%M:%S").time())
                    logger.info(f"Detected last end time from grid: {last_end_str}")
                except Exception as e:
                    logger.warning(f"Failed parse last_end_str='{last_end_str}': {e}")
                    last_end_dt = None
        else:
            logger.info("No rows found before Add; will use default start time base.")

        now = datetime.now()
        if last_end_dt:
            base_dt = last_end_dt + timedelta(minutes=1)
            base_dt += timedelta(minutes=random.randint(0, 3))
            start_dt = base_dt
        else:
            start_dt = datetime.combine(now.date(), datetime.min.time()) + timedelta(hours=17, minutes=random.randint(0, 59))

        end_dt = start_dt + timedelta(minutes=10)
        start_time = start_dt.strftime("%H:%M:%S")
        end_time = end_dt.strftime("%H:%M:%S")
        logger.info(f"Will add new row with Start={start_time}, End={end_time}")

    # --- Rest of your code stays the same (click add, set values, save) ---
    # (unchanged from your original working code)

# ------------------- Rest of your code (reject function, login, close_rms_if_running, run_workflow_for_user) -------------------
# Unchanged

# ------------------- Main -------------------
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--starttime", help="Override start time (HH:MM:SS)", required=False)
    parser.add_argument("--endtime", help="Override end time (HH:MM:SS)", required=False)
    args = parser.parse_args()

    if args.starttime and not TIME_RE.match(args.starttime):
        raise ValueError("Invalid --starttime format. Use HH:MM:SS")
    if args.endtime and not TIME_RE.match(args.endtime):
        raise ValueError("Invalid --endtime format. Use HH:MM:SS")

    try:
        start_time_value = run_workflow_for_user("QA1", "change@1212", is_rash1=False,
                                                start_time_value=None,
                                                override_start=args.starttime,
                                                override_end=args.endtime)
        run_workflow_for_user("rash1", "change@1212", is_rash1=True, start_time_value=start_time_value)
        logger.info("Automation script completed successfully for both users.")
    except Exception as e:
        logger.exception(f"Automation failed: {e}")


if __name__ == "__main__":
    main()
