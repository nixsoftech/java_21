import time
import os
import random
import logging
from datetime import datetime, timedelta
from pywinauto.application import Application
from pywinauto.keyboard import send_keys
from pywinauto.timings import TimeoutError

# ---------------- Logging Setup ----------------
script_name = os.path.splitext(os.path.basename(__file__))[0]
log_dir = os.path.join(os.getcwd(), "logs")
os.makedirs(log_dir, exist_ok=True)

timestamp = datetime.now().strftime("%Y-%m-%d_%H%M%S")
log_file = os.path.join(log_dir, f"{script_name}_{timestamp}.log")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler(log_file, mode="w", encoding="utf-8"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ---------------- Helper Functions ----------------
def safe_type(window, auto_id, control_type, text, retries=5, delay=2):
    for attempt in range(1, retries + 1):
        try:
            ctrl = window.child_window(auto_id=auto_id, control_type=control_type)
            ctrl.wait("enabled", timeout=5).type_keys(text, with_spaces=True)
            logger.info(f"Typed '{text}' into {auto_id} (attempt {attempt})")
            return True
        except Exception as e:
            logger.warning(f"Attempt {attempt} failed for {auto_id}: {e}")
            time.sleep(delay)
    raise TimeoutError(f"Failed to type into {auto_id} after {retries} attempts")

def safe_select(window, auto_id, control_type, value, retries=5, delay=2):
    for attempt in range(1, retries + 1):
        try:
            ctrl = window.child_window(auto_id=auto_id, control_type=control_type)
            ctrl.wait("enabled", timeout=5).select(value)
            logger.info(f"Selected '{value}' in {auto_id} (attempt {attempt})")
            return True
        except Exception as e:
            logger.warning(f"Attempt {attempt} failed for {auto_id}: {e}")
            time.sleep(delay)
    raise TimeoutError(f"Failed to select {value} in {auto_id} after {retries} attempts")

def safe_click(window, auto_id=None, title=None, control_type="Button", retries=5, delay=2):
    for attempt in range(1, retries + 1):
        try:
            ctrl = window.child_window(auto_id=auto_id, title=title, control_type=control_type)
            ctrl.wait("enabled", timeout=5).click_input()
            time.sleep(0.5)
            logger.info(f"Clicked {auto_id or title} (attempt {attempt})")
            return True
        except Exception as e:
            logger.warning(f"Attempt {attempt} failed for {auto_id or title}: {e}")
            time.sleep(delay)
    raise TimeoutError(f"Failed to click {auto_id or title} after {retries} attempts")

def click_rms_configuration_and_peak_margin(main_win):
    try:
        logger.info("Navigating to RMS Configuration -> Peak Margin via menu_select...")
        main_win.menu_select("RMS Configuration->Peak Margin")
        logger.info("Successfully opened Peak Margin window.")
    except Exception:
        logger.warning("menu_select failed, using fallback clicks...")
        safe_click(main_win, title="RMS Configuration", control_type="MenuItem")
        time.sleep(1)
        safe_click(main_win, title="Peak Margin", control_type="MenuItem")

# ------------------- QA1 Logic -------------------
def qa1_add_row(app, main_win):
    peak_margin_win = main_win.child_window(title="Peak Margin", control_type="Window")
    peak_margin_win.wait("visible", timeout=10)

    # ✅ Only QA1 clicks "Add"
    safe_click(peak_margin_win, title="Add", control_type="Button")
    time.sleep(1)

    tables = peak_margin_win.descendants(control_type="Table")
    if not tables:
        raise RuntimeError("No tables found in Peak Margin window.")
    grid = tables[0]
    cells = grid.descendants(control_type="DataItem")
    columns_per_row = 9
    rows = [cells[i:i + columns_per_row] for i in range(0, len(cells), columns_per_row)]
    last_row = rows[-1]

    now = datetime.now()
    start_time_value = (datetime.combine(now.date(), datetime.min.time()) +
                        timedelta(hours=17, minutes=random.randint(0, 59))).strftime("%H:%M:%S")
    end_time_value = (datetime.strptime(start_time_value, "%H:%M:%S") + timedelta(minutes=10)).strftime("%H:%M:%S")
    logger.info(f"Filling new row with Start={start_time_value}, End={end_time_value}")

    def set_cell_value(cell, value):
        cell.click_input()
        cell.type_keys("{F2}")
        time.sleep(0.3)
        send_keys("^a{BACKSPACE}")
        send_keys(value)
        send_keys("{ENTER}")

    set_cell_value(last_row[1], start_time_value)
    set_cell_value(last_row[2], end_time_value)

    safe_click(peak_margin_win, title="Save", control_type="Button")
    time.sleep(2)

    return start_time_value  # return value in memory (no file)

# ------------------- rash1 Logic -------------------
def rash1_reject_row(app, main_win, start_time_value):
    peak_margin_win = main_win.child_window(title="Peak Margin", control_type="Window")
    peak_margin_win.wait("visible", timeout=10)

    tables = peak_margin_win.descendants(control_type="Table")
    grid = tables[0]
    cells = grid.descendants(control_type="DataItem")
    columns_per_row = 9
    rows = [cells[i:i + columns_per_row] for i in range(0, len(cells), columns_per_row)]

    logger.info(f"Searching for row with Start Time = {start_time_value}")
    for row in rows:
        start_cell = row[1]
        if start_time_value in start_cell.window_text():
            logger.info(f"Match found. Clicking Edit checkbox for row.")
            row[8].click_input()
            time.sleep(0.5)

            status_cell = row[5]
            status_cell.click_input(double=True)
            time.sleep(0.5)
            send_keys("{DOWN}")  # Move to REJECT option
            send_keys("{ENTER}")
            logger.info("Selected REJECT from dropdown.")

            safe_click(peak_margin_win, title="Save", control_type="Button")
            time.sleep(2)
            return

    raise RuntimeError(f"No row found with Start Time = {start_time_value}")

# ------------------- Main -------------------
def login_and_run(user_id, start_time_value=None):
    app = Application(backend="uia").start(r"D:\Program Files (x86)\NCCL Ltd\RMSSetup\RMS FE.exe")
    dlg = app.window(title_re=".*Risk Management System - Login")
    dlg.wait("visible", timeout=30)

    safe_type(dlg, "txt_UserId", "Edit", user_id)
    safe_type(dlg, "txt_Password", "Edit", "change@1212")
    safe_select(dlg, "cmb_Envionrnment", "ComboBox", "UAT")
    safe_select(dlg, "cmb_loginMethod", "ComboBox", "RMS")
    safe_click(dlg, auto_id="btn_Submit", control_type="Button")

    main_win = app.window(title_re=".*NCDEX RISK MANAGEMENT SYSTEM.*")
    main_win.wait("visible", timeout=40)

    click_rms_configuration_and_peak_margin(main_win)

    if user_id.lower() == "qa1":
        return qa1_add_row(app, main_win)
    else:
        rash1_reject_row(app, main_win, start_time_value)

if __name__ == "__main__":
    start_time_value = login_and_run("QA1")   # ✅ Adds row
    login_and_run("rash1", start_time_value)  # ✅ Finds and rejects row
