def handle_peak_margin(app, main_win):
    logger.info("Looking for Peak Margin panel inside main window...")

    # Locate Peak Margin window/panel
    try:
        peak_margin_win = main_win.child_window(title="Peak Margin", control_type="Window")
        peak_margin_win.wait("visible", timeout=10)
        logger.info("Peak Margin panel detected and ready.")
    except TimeoutError:
        logger.error("Peak Margin panel not found. Dumping children for debugging...")
        logger.error(main_win.print_control_identifiers())
        raise

    # ---- Step 1: Click Add Button ----
    safe_click(peak_margin_win, title="Add", control_type="Button")
    time.sleep(1)  # give UI time to add row

    # ---- Step 2: Get all rows ----
    grid = peak_margin_win.child_window(control_type="Table")
    grid.wait("exists ready", timeout=10)
    rows = grid.children(control_type="Custom")
    if not rows:
        logger.error("No rows detected in Peak Margin grid!")
        logger.error(grid.print_control_identifiers())
        raise RuntimeError("No rows found in grid after clicking Add")
    logger.info(f"Detected {len(rows)} rows. Selecting last row...")
    last_row = rows[-1]

    # ---- Step 3: Check if it's a new row ----
    row_value = last_row.legacy_properties().get("Value", "")
    if "(null)" not in row_value:
        logger.warning("Last row already contains data! Skipping data entry.")
        return

    # ---- Step 4: Generate random times ----
    now = datetime.now()
    start_time = (datetime.combine(now.date(), datetime.min.time()) + timedelta(hours=17) +
                  timedelta(minutes=random.randint(0, 59))).strftime("%H:%M:%S")
    end_time = (datetime.strptime(start_time, "%H:%M:%S") + timedelta(minutes=10)).strftime("%H:%M:%S")
    exec_time = start_time
    logger.info(f"Filling new row with Start={start_time}, End={end_time}, Exec={exec_time}")

    # ---- Step 5: Fill Start Time ----
    try:
        start_cell = last_row.child_window(title_re="Start Time.*", control_type="DataItem")
        start_cell.double_click_input()
        send_keys(start_time)
        send_keys("{TAB}")
        time.sleep(0.2)

        # ---- Fill End Time ----
        end_cell = last_row.child_window(title_re="End Time.*", control_type="DataItem")
        end_cell.double_click_input()
        send_keys(end_time)
        send_keys("{TAB}")
        time.sleep(0.2)

        # ---- Fill Executable Time ----
        exec_cell = last_row.child_window(title_re="Executable Time.*", control_type="DataItem")
        exec_cell.double_click_input()
        send_keys(exec_time)
        send_keys("{TAB}")
        time.sleep(0.2)

        # ---- Fill Flag (Y) ----
        flag_cell = last_row.child_window(title_re="Flag.*", control_type="DataItem")
        flag_cell.double_click_input()
        send_keys("Y")
        send_keys("{TAB}")

    except Exception as e:
        logger.error(f"Failed to fill row data: {e}")
        logger.error(last_row.print_control_identifiers())
        raise

    # ---- Step 6: Save the Row ----
    safe_click(peak_margin_win, title="Save", control_type="Button")
    time.sleep(2)

    # ---- Step 7: Verify Status ----
    updated_value = last_row.legacy_properties().get("Value", "")
    if "PENDING" in updated_value.upper():
        logger.info("Status verification PASSED: PENDING found in last row.")
    else:
        logger.warning(f"Status verification FAILED. Row value: {updated_value}")
