import time
import os
import random
import logging
from datetime import datetime, timedelta
from pywinauto.application import Application
from pywinauto.keyboard import send_keys
from pywinauto.timings import TimeoutError

# ---------------- Logging Setup ----------------
script_name = os.path.splitext(os.path.basename(__file__))[0]
log_dir = os.path.join(os.getcwd(), "logs")
os.makedirs(log_dir, exist_ok=True)

timestamp = datetime.now().strftime("%Y-%m-%d_%H%M%S")
log_file = os.path.join(log_dir, f"{script_name}_{timestamp}.log")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler(log_file, mode="w", encoding="utf-8"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ---------------- Helper Functions ----------------
def safe_type(window, auto_id, control_type, text, retries=5, delay=2):
    for attempt in range(1, retries + 1):
        try:
            ctrl = window.child_window(auto_id=auto_id, control_type=control_type)
            ctrl.wait("enabled", timeout=5).type_keys(text, with_spaces=True)
            logger.info(f"Typed '{text}' into {auto_id} (attempt {attempt})")
            return True
        except Exception as e:
            logger.warning(f"Attempt {attempt} failed for {auto_id}: {e}")
            time.sleep(delay)
    raise TimeoutError(f"Failed to type into {auto_id} after {retries} attempts")

def safe_select(window, auto_id, control_type, value, retries=5, delay=2):
    for attempt in range(1, retries + 1):
        try:
            ctrl = window.child_window(auto_id=auto_id, control_type=control_type)
            ctrl.wait("enabled", timeout=5).select(value)
            logger.info(f"Selected '{value}' in {auto_id} (attempt {attempt})")
            return True
        except Exception as e:
            logger.warning(f"Attempt {attempt} failed for {auto_id}: {e}")
            time.sleep(delay)
    raise TimeoutError(f"Failed to select {value} in {auto_id} after {retries} attempts")

def safe_click(window, auto_id=None, title=None, control_type="Button", retries=5, delay=2):
    for attempt in range(1, retries + 1):
        try:
            ctrl = window.child_window(auto_id=auto_id, title=title, control_type=control_type)
            ctrl.wait("enabled", timeout=5).click_input()
            time.sleep(0.5)
            logger.info(f"Clicked {auto_id or title} (attempt {attempt})")
            return True
        except Exception as e:
            logger.warning(f"Attempt {attempt} failed for {auto_id or title}: {e}")
            time.sleep(delay)
    raise TimeoutError(f"Failed to click {auto_id or title} after {retries} attempts")

def handle_popup(app, expected_substring=None, auto_id_to_click=None, timeout=15):
    try:
        popup = app.window(title_re=".*")
        popup.wait("visible", timeout=timeout)
        popup_text = popup.window_text().strip()
        logger.info(f"Popup detected: '{popup_text}'")

        if expected_substring and expected_substring.lower() not in popup_text.lower():
            logger.warning(f"Popup text mismatch. Expected '{expected_substring}' but got '{popup_text}'")

        if auto_id_to_click:
            btn = popup.child_window(auto_id=auto_id_to_click, control_type="Button")
            btn.wait("enabled", timeout=5).click_input()
            logger.info(f"Clicked popup button with AutomationId={auto_id_to_click}")

        return True
    except TimeoutError:
        logger.info(f"No popup appeared within {timeout}s.")
        return False

# ---------------- Peak Margin Handler ----------------
def handle_peak_margin(app, main_win):
    logger.info("Opening Peak Margin window...")
    peak_margin_win = main_win.child_window(title="Peak Margin", control_type="Window")
    peak_margin_win.wait("visible", timeout=10)
    logger.info("Peak Margin window is visible.")

    # Count cells before Add
    tables = peak_margin_win.descendants(control_type="Table") + peak_margin_win.descendants(control_type="List")
    if not tables:
        raise RuntimeError("No table/list found in Peak Margin window")
    grid = tables[0]
    all_cells_before = grid.descendants(control_type="DataItem")
    logger.info(f"Cell count before Add = {len(all_cells_before)}")

    # Click Add
    safe_click(peak_margin_win, title="Add", control_type="Button")
    logger.info("Clicked Add, waiting for new row...")

    # Wait until cell count increases
    for i in range(10):
        all_cells_after = grid.descendants(control_type="DataItem")
        if len(all_cells_after) > len(all_cells_before):
            logger.info(f"New cell count = {len(all_cells_after)} after {i+1} checks")
            break
        time.sleep(1)
    else:
        raise RuntimeError("No new row detected after Add")

    # Dump flat cells for debugging
    logger.info("=== Flat cell dump AFTER Add (index: text) ===")
    for idx, c in enumerate(all_cells_after):
        logger.info(f"Cell {idx:03d}: '{c.window_text()}'")
    logger.info("=== End cell dump ===")

    # Select last row based on fixed column count (8 columns per row)
    columns_per_row = 8
    rows = [all_cells_after[i:i + columns_per_row] for i in range(0, len(all_cells_after), columns_per_row)]
    last_row_cells = rows[-1]
    logger.info(f"Selected last row with {len(last_row_cells)} cells (row index = {len(rows)-1}).")

    # Pick start/end time relative to now
    now = datetime.now()
    start_time = now.strftime("%H:%M:%S")
    end_time = (now + timedelta(minutes=10)).strftime("%H:%M:%S")
    logger.info(f"Filling Start={start_time}, End={end_time}")

    # Helper for F2 editing
    def set_cell_value(cell, value, max_attempts=3):
        for attempt in range(1, max_attempts + 1):
            try:
                cell.click_input()
                cell.type_keys("{F2}")
                time.sleep(0.3)
                send_keys("^a{BACKSPACE}")
                send_keys(value)
                send_keys("{ENTER}")
                time.sleep(0.3)
                logger.info(f"Set cell value '{value}' (attempt {attempt})")
                return
            except Exception as e:
                logger.warning(f"Failed to set cell value '{value}' (attempt {attempt}): {e}")
                time.sleep(0.5)
        raise TimeoutError(f"Failed to set value '{value}' after {max_attempts} attempts")

    set_cell_value(last_row_cells[1], start_time)
    set_cell_value(last_row_cells[2], end_time)

    # Save
    safe_click(peak_margin_win, title="Save", control_type="Button")
    time.sleep(2)
    logger.info("Clicked Save, waiting for confirmation popup...")

    try:
        popup = app.window(best_match="Risk Management System")
        popup.wait("visible", timeout=10)
        try:
            popup_text = popup.child_window(auto_id="65535", control_type="Text").window_text()
            logger.info(f"Popup message: {popup_text}")
        except Exception:
            logger.warning("Popup text not found.")
        safe_click(popup, auto_id="2", control_type="Button")
        logger.info("Clicked OK on confirmation popup.")
    except Exception as e:
        logger.error(f"Failed to handle confirmation popup: {e}")
        raise

    logger.info("Row filled, saved, and popup confirmed successfully.")

# ---------------- Main ----------------
def main():
    try:
        logger.info("Starting RMS Application...")
        app = Application(backend="uia").start(
            r"D:\Program Files (x86)\NCCL Ltd\RMSSetup\RMS FE.exe"
        )

        dlg = app.window(title_re=".*Risk Management System - Login")
        dlg.wait("visible", timeout=30)

        safe_type(dlg, "txt_UserId", "Edit", "QA1")
        safe_type(dlg, "txt_Password", "Edit", "change@1212")
        safe_select(dlg, "cmb_Envionrnment", "ComboBox", "UAT")
        safe_select(dlg, "cmb_loginMethod", "ComboBox", "RMS")
        safe_click(dlg, auto_id="btn_Submit", control_type="Button")

        handle_popup(app, expected_substring="login to test/mock environment", auto_id_to_click="6", timeout=10)

        main_win = app.window(title_re=".*NCDEX RISK MANAGEMENT SYSTEM.*")
        main_win.wait("visible", timeout=40)
        logger.info("Main RMS window loaded.")

        time.sleep(10)  # allow UI to settle
        handle_peak_margin(app, main_win)

        safe_click(main_win, title="Exit", control_type="MenuItem")
        handle_popup(app, auto_id_to_click="6", timeout=10)

        logger.info("Automation script completed successfully.")
    except Exception as e:
        logger.exception(f"Automation failed: {e}")

if __name__ == "__main__":
    main()
