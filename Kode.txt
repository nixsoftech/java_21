import argparse
import logging
import random
import time
import re
from datetime import datetime, timedelta
from pywinauto.application import Application
from pywinauto.keyboard import send_keys

# ------------------- Logging Setup -------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

TIME_RE = re.compile(r"^\d{2}:\d{2}:\d{2}$")

# ------------------- Helper Functions -------------------

def safe_click(win, **kwargs):
    """Safely clicks a control if it exists."""
    try:
        ctrl = win.child_window(**kwargs)
        ctrl.wait("enabled", timeout=5)
        ctrl.click_input()
        logger.info(f"Clicked {kwargs}")
        return True
    except Exception as e:
        logger.error(f"Failed to click {kwargs}: {e}")
        return False


def set_cell_value(cell, value):
    """Focus cell, double-click, send value."""
    try:
        cell.click_input(double=True)
        time.sleep(0.5)
        send_keys("^a{BACKSPACE}")
        send_keys(value)
        send_keys("{TAB}")
        logger.info(f"Set cell value: {value}")
    except Exception as e:
        logger.error(f"Failed to set cell value: {e}")


def get_grid_rows_and_meta(peak_margin_win):
    """Returns grid rows, column count, and indices of time columns."""
    try:
        grid = peak_margin_win.child_window(control_type="Table")
        rows = grid.children()
        rows_data = []
        for r in rows:
            cells = r.children()
            row_values = [c.window_text() for c in cells]
            rows_data.append((cells, row_values))
        time_cols = [i for i, v in enumerate(rows_data[0][1]) if TIME_RE.match(v)] if rows_data else []
        return rows_data, len(rows_data[0][1]) if rows_data else 0, time_cols
    except Exception as e:
        logger.warning(f"Failed to read grid: {e}")
        return [], 0, []


def handle_popup(app, auto_id_to_click, timeout=5):
    """Handles confirmation popups if they appear."""
    try:
        popup = app.window(best_match="Risk Management System")
        popup.wait("visible", timeout=timeout)
        safe_click(popup, auto_id=auto_id_to_click, control_type="Button")
        logger.info("Handled popup successfully.")
    except Exception:
        logger.warning("No popup found (or could not handle it).")


# ------------------- Peak Margin Add -------------------
def handle_peak_margin_add(app, main_win, manual_start=None, manual_end=None):
    peak_margin_win = main_win.child_window(title="Peak Margin", control_type="Window")
    peak_margin_win.wait("visible", timeout=10)

    rows_before, _, _ = get_grid_rows_and_meta(peak_margin_win)
    last_end_dt = None

    # Parse last end time if available
    if not manual_start and rows_before:
        last_row_values = rows_before[-1][1]
        times_in_row = [v for v in last_row_values if TIME_RE.match(v)]
        if len(times_in_row) >= 2:
            last_end_str = times_in_row[1]
        elif len(times_in_row) == 1:
            last_end_str = times_in_row[0]
        else:
            last_end_str = None

        if last_end_str:
            today = datetime.now().date()
            try:
                last_end_dt = datetime.combine(today, datetime.strptime(last_end_str, "%H:%M:%S").time())
                logger.info(f"Detected last end time: {last_end_str}")
            except Exception as e:
                logger.warning(f"Could not parse last_end_str '{last_end_str}': {e}")

    # Determine Start & End Times
    if manual_start and manual_end:
        start_time = manual_start
        end_time = manual_end
        logger.info(f"Using manual Start={start_time}, End={end_time}")
    else:
        now = datetime.now()
        if last_end_dt:
            start_dt = last_end_dt + timedelta(minutes=1 + random.randint(0, 3))
        else:
            start_dt = datetime.combine(now.date(), datetime.min.time()) + timedelta(hours=17, minutes=random.randint(0, 59))
        end_dt = start_dt + timedelta(minutes=10)
        start_time = start_dt.strftime("%H:%M:%S")
        end_time = end_dt.strftime("%H:%M:%S")
        logger.info(f"Calculated Start={start_time}, End={end_time}")

    safe_click(peak_margin_win, title="Add", control_type="Button")
    time.sleep(1.0)

    rows_after, _, time_cols_after = get_grid_rows_and_meta(peak_margin_win)
    last_row_cells = rows_after[-1][0]
    start_col_index = time_cols_after[0] if len(time_cols_after) >= 1 else 1
    end_col_index = time_cols_after[1] if len(time_cols_after) >= 2 else 2

    set_cell_value(last_row_cells[start_col_index], start_time)
    set_cell_value(last_row_cells[end_col_index], end_time)

    safe_click(peak_margin_win, title="Save", control_type="Button")
    time.sleep(1.0)
    handle_popup(app, auto_id_to_click="2", timeout=8)
    return start_time


# ------------------- Reject/Approve Handler -------------------
def handle_peak_margin_reject_for_rash1(app, main_win, start_time_value, approve=False):
    peak_margin_win = main_win.child_window(title="Peak Margin", control_type="Window")
    peak_margin_win.wait("visible", timeout=10)

    rows, _, _ = get_grid_rows_and_meta(peak_margin_win)
    matched = False

    for cells, values in rows:
        if start_time_value in values:
            checkbox = cells[0]
            checkbox.click_input()
            logger.info(f"Selected checkbox for Start={start_time_value}")
            time.sleep(1.0)

            status_cell = cells[-1]
            status_cell.click_input(double=True)
            time.sleep(0.5)
            send_keys("%{DOWN}")  # Alt+Down to open dropdown
            time.sleep(0.5)
            send_keys("APPROVE{ENTER}" if approve else "REJECT{ENTER}")
            logger.info(f"{'Approved' if approve else 'Rejected'} Start={start_time_value}")
            matched = True
            break

    if not matched:
        logger.error(f"No row found with Start Time: {start_time_value}")

    safe_click(peak_margin_win, title="Save", control_type="Button")
    time.sleep(1.0)
    handle_popup(app, auto_id_to_click="2", timeout=8)


# ------------------- Workflow Runner -------------------
def run_workflow_for_user(username, password, is_rash1=False, start_time_value=None, manual_start=None, manual_end=None, approve=False):
    logger.info(f"Running workflow for user: {username}")
    app = Application(backend="uia").start(r"D:\Program Files (x86)\NCCL Ltd\RMSSetup\RMS FE.exe")

    main_win = app.window(best_match="RMS FE")
    main_win.wait("visible", timeout=15)

    if not is_rash1:
        start_time = handle_peak_margin_add(app, main_win, manual_start=manual_start, manual_end=manual_end)
    else:
        if not start_time_value:
            raise ValueError("start_time_value is required for rash1")
        handle_peak_margin_reject_for_rash1(app, main_win, start_time_value, approve=approve)
        start_time = None

    safe_click(main_win, title="Exit", control_type="MenuItem")
    handle_popup(app, auto_id_to_click="6", timeout=5)
    return start_time


# ------------------- CLI Argument Parser -------------------
def parse_args():
    parser = argparse.ArgumentParser(description="Peak Margin Automation Script")
    parser.add_argument("--starttime", type=str, help="Manual Start Time (HH:MM:SS)")
    parser.add_argument("--endtime", type=str, help="Manual End Time (HH:MM:SS)")
    parser.add_argument("--approve", action="store_true", help="Approve instead of Reject for rash1")
    return parser.parse_args()


def validate_time_format(value):
    if value and not TIME_RE.match(value):
        raise ValueError(f"Invalid time format: {value}. Expected HH:MM:SS.")


# ------------------- Main -------------------
def main():
    args = parse_args()
    try:
        validate_time_format(args.starttime)
        validate_time_format(args.endtime)

        start_time_value = run_workflow_for_user(
            "QA1", "change@1212",
            is_rash1=False,
            manual_start=args.starttime,
            manual_end=args.endtime
        )
        run_workflow_for_user(
            "rash1", "change@1212",
            is_rash1=True,
            start_time_value=start_time_value,
            approve=args.approve
        )
        logger.info("Automation completed successfully for both users.")
    except Exception as e:
        logger.exception(f"Automation failed: {e}")


if __name__ == "__main__":
    main()
