import time
import os
import random
import logging
import psutil
from datetime import datetime, timedelta
from pywinauto.application import Application
from pywinauto.keyboard import send_keys
from pywinauto.timings import TimeoutError
from pywinauto import timings

# ---------------- Logging Setup ----------------
script_name = os.path.splitext(os.path.basename(__file__))[0]
log_dir = os.path.join(os.getcwd(), "logs")
os.makedirs(log_dir, exist_ok=True)

timestamp = datetime.now().strftime("%Y-%m-%d_%H%M%S")
log_file = os.path.join(log_dir, f"{script_name}_{timestamp}.log")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler(log_file, mode="w", encoding="utf-8"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ---------------- Helper Functions ----------------
def safe_type(window, auto_id, control_type, text, retries=5, delay=2):
    for attempt in range(1, retries + 1):
        try:
            ctrl = window.child_window(auto_id=auto_id, control_type=control_type)
            ctrl.wait("enabled", timeout=5).type_keys(text, with_spaces=True)
            logger.info(f"Typed '{text}' into {auto_id} (attempt {attempt})")
            return True
        except Exception as e:
            logger.warning(f"Attempt {attempt} failed for {auto_id}: {e}")
            time.sleep(delay)
    raise TimeoutError(f"Failed to type into {auto_id} after {retries} attempts")

def safe_select(window, auto_id, control_type, value, retries=5, delay=2):
    for attempt in range(1, retries + 1):
        try:
            ctrl = window.child_window(auto_id=auto_id, control_type=control_type)
            ctrl.wait("enabled", timeout=5).select(value)
            logger.info(f"Selected '{value}' in {auto_id} (attempt {attempt})")
            return True
        except Exception as e:
            logger.warning(f"Attempt {attempt} failed for {auto_id}: {e}")
            time.sleep(delay)
    raise TimeoutError(f"Failed to select {value} in {auto_id} after {retries} attempts")

def safe_click(window, auto_id=None, title=None, control_type="Button", retries=5, delay=2):
    for attempt in range(1, retries + 1):
        try:
            ctrl = window.child_window(auto_id=auto_id, title=title, control_type=control_type)
            ctrl.wait("enabled", timeout=5).click_input()
            time.sleep(0.5)
            logger.info(f"Clicked {auto_id or title} (attempt {attempt})")
            return True
        except Exception as e:
            logger.warning(f"Attempt {attempt} failed for {auto_id or title}: {e}")
            time.sleep(delay)
    raise TimeoutError(f"Failed to click {auto_id or title} after {retries} attempts")

def handle_popup(app, expected_substring=None, auto_id_to_click=None, timeout=15):
    try:
        popup = app.window(title_re=".*")
        popup.wait("visible", timeout=timeout)
        popup_text = popup.window_text().strip()
        logger.info(f"Popup detected: '{popup_text}'")

        if expected_substring and expected_substring.lower() not in popup_text.lower():
            logger.warning(f"Popup text mismatch. Expected '{expected_substring}' but got '{popup_text}'")

        if auto_id_to_click:
            try:
                btn = popup.child_window(auto_id=auto_id_to_click, control_type="Button")
                btn.wait("enabled", timeout=5).click_input()
                logger.info(f"Clicked popup button with AutomationId={auto_id_to_click}")
            except Exception as e:
                logger.error(f"Failed to click popup button with AutomationId={auto_id_to_click}: {e}")
        return True

    except TimeoutError:
        logger.info(f"No popup appeared within {timeout}s.")
        return False

def handle_post_login_popups(app, main_win, timeout=20):
    try:
        logger.info("Waiting for 'BMS OpmsEngine Got abandoned' popup...")
        popup1 = main_win.child_window(title="Risk Management System", control_type="Window")
        popup1.wait("visible", timeout=timeout)
        safe_click(popup1, auto_id="2", control_type="Button")
        logger.info("[Popup1] Clicked OK")

        time.sleep(2)
        logger.info("Waiting for 'Do you want to close RMS' popup...")
        popup2 = main_win.child_window(title="Risk Management System", control_type="Window")
        popup2.wait("visible", timeout=timeout)
        safe_click(popup2, auto_id="7", control_type="Button")
        logger.info("[Popup2] Clicked NO")

    except TimeoutError:
        logger.warning("No post-login popups appeared within timeout.")

def click_rms_configuration_and_peak_margin(main_win):
    try:
        logger.info("Navigating to RMS Configuration -> Peak Margin via menu_select...")
        main_win.menu_select("RMS Configuration->Peak Margin")
        logger.info("Successfully opened Peak Margin window.")
    except Exception:
        logger.warning("menu_select failed, using fallback clicks...")
        safe_click(main_win, title="RMS Configuration", control_type="MenuItem")
        time.sleep(1)
        safe_click(main_win, title="Peak Margin", control_type="MenuItem")

# ------------------- Peak Margin Add (QA1) -------------------
def set_cell_value(cell, value, max_attempts=3):
    """Safely sets a value in a grid cell with retries."""
    for attempt in range(1, max_attempts + 1):
        try:
            cell.click_input(double=False)
            cell.type_keys("{F2}")
            time.sleep(0.3)
            send_keys("^a{BACKSPACE}", pause=0.05)
            send_keys(value, pause=0.05)
            send_keys("{ENTER}", pause=0.05)
            time.sleep(0.3)
            return
        except Exception as e:
            logger.warning(f"Attempt {attempt} failed to set value '{value}': {e}")
            time.sleep(0.5)
    raise TimeoutError(f"Failed to set value '{value}' after {max_attempts} attempts")

def handle_peak_margin_add(app, main_win):
    logger.info("Looking for Peak Margin panel inside main window...")
    peak_margin_win = main_win.child_window(title="Peak Margin", control_type="Window")
    peak_margin_win.wait("visible", timeout=10)

    logger.info("Peak Margin panel detected. Clicking Add...")
    safe_click(peak_margin_win, title="Add", control_type="Button")
    time.sleep(2)

    tables = peak_margin_win.descendants(control_type="Table") + peak_margin_win.descendants(control_type="List")
    if not tables:
        raise RuntimeError("No tables/list views found in Peak Margin window after clicking Add")

    grid = tables[0]

    # Wait until last row appears
    for attempt in range(5):
        all_data_items = grid.descendants(control_type="DataItem")
        if len(all_data_items) >= 8:
            break
        logger.warning(f"Attempt {attempt+1}: Only {len(all_data_items)} cells found, retrying...")
        time.sleep(1)
    if len(all_data_items) < 8:
        raise RuntimeError(f"Not enough cells after Add: found {len(all_data_items)}")

    columns_per_row = 8
    rows = [all_data_items[i:i + columns_per_row] for i in range(0, len(all_data_items), columns_per_row)]
    last_row_cells = rows[-1]
    logger.info(f"Selected last row with {len(last_row_cells)} cells.")

    now = datetime.now()
    start_time = (datetime.combine(now.date(), datetime.min.time()) +
                  timedelta(hours=17, minutes=random.randint(0, 59))).strftime("%H:%M:%S")
    end_time = (datetime.strptime(start_time, "%H:%M:%S") + timedelta(minutes=10)).strftime("%H:%M:%S")
    logger.info(f"Filling new row with Start={start_time}, End={end_time}")

    set_cell_value(last_row_cells[1], start_time)
    set_cell_value(last_row_cells[2], end_time)

    safe_click(peak_margin_win, title="Save", control_type="Button")
    time.sleep(2)

    try:
        popup = app.window(best_match="Risk Management System")
        popup.wait("visible", timeout=10)
        safe_click(popup, auto_id="2", control_type="Button")
    except Exception as e:
        logger.error(f"Failed to handle confirmation popup: {e}")
        raise

    return start_time

# ------------------- Peak Margin Reject (rash1) -------------------
def dump_peak_margin_grid(grid):
    """Debug helper to dump all rows/columns in the grid."""
    all_data_items = grid.descendants(control_type="DataItem")
    columns_per_row = 9
    rows = [all_data_items[i:i + columns_per_row] for i in range(0, len(all_data_items), columns_per_row)]
    logger.info(f"Dumping {len(rows)} rows from Peak Margin grid:")
    for r_idx, row in enumerate(rows):
        row_values = []
        for c_idx, cell in enumerate(row):
            try:
                # Call legacy_properties as a method
                props = cell.legacy_properties() if hasattr(cell, "legacy_properties") else {}
                val = props.get("Value", "") or cell.window_text()
            except Exception as e:
                val = f"<Error:{e}>"
            row_values.append(val)
        logger.info(f"Row {r_idx}: {row_values}")
    return rows

def handle_peak_margin_reject_for_rash1(app, main_win, target_start_time, max_wait_seconds=20, poll_interval=1):
    logger.info(f"Looking for Peak Margin panel for rash1 to reject start_time={target_start_time}...")
    peak_margin_win = main_win.child_window(title="Peak Margin", control_type="Window")
    peak_margin_win.wait("visible", timeout=10)

    end_time = time.time() + max_wait_seconds
    found = False
    last_exception = None

    while time.time() < end_time:
        try:
            tables = peak_margin_win.descendants(control_type="Table") + peak_margin_win.descendants(control_type="List")
            if not tables:
                time.sleep(poll_interval)
                continue
            grid = tables[0]
            rows = dump_peak_margin_grid(grid)

            for r_idx, row in enumerate(rows):
                try:
                    start_cell_text = row[1]
                    if start_cell_text == target_start_time:
                        logger.info(f"Matched row {r_idx} with Start Time '{start_cell_text}'")

                        # Click Edit checkbox (last column)
                        try:
                            all_data_items = grid.descendants(control_type="DataItem")
                            row_cells = [all_data_items[i:i+9] for i in range(0, len(all_data_items), 9)][r_idx]
                            row_cells[8].click_input()
                            logger.info("Clicked Edit checkbox.")
                        except Exception:
                            row_cells[8].set_focus()
                            row_cells[8].click_input()

                        time.sleep(0.5)

                        # Open status dropdown and select REJECT
                        status_cell = row_cells[5]
                        try:
                            status_cell.click_input()
                            time.sleep(0.2)
                            status_cell.type_keys("{F2}")
                        except Exception:
                            status_cell.click_input()

                        time.sleep(0.3)
                        send_keys("{DOWN}{ENTER}", pause=0.05)
                        logger.info("Selected REJECT in status dropdown.")

                        # Save and handle popup
                        safe_click(peak_margin_win, title="Save", control_type="Button")
                        time.sleep(1.5)
                        try:
                            popup = app.window(best_match="Risk Management System")
                            popup.wait("visible", timeout=8)
                            safe_click(popup, auto_id="2", control_type="Button")
                            logger.info("Clicked OK on confirmation popup.")
                        except Exception:
                            logger.warning("No confirmation popup after save.")

                        found = True
                        return
                except Exception as e:
                    last_exception = e

            time.sleep(poll_interval)
        except Exception as e:
            last_exception = e
            time.sleep(poll_interval)

    msg = f"No row found with Start Time = {target_start_time} within {max_wait_seconds}s"
    logger.error(msg)
    if last_exception:
        logger.debug(f"Last exception: {last_exception}")
    raise RuntimeError(msg)

# ------------------- Login -------------------
def login_user(app, username, password, environment="UAT"):
    dlg = app.window(title_re=".*Risk Management System - Login")
    dlg.wait("visible", timeout=30)

    safe_type(dlg, "txt_UserId", "Edit", username)
    safe_type(dlg, "txt_Password", "Edit", password)
    safe_select(dlg, "cmb_Envionrnment", "ComboBox", environment)
    safe_select(dlg, "cmb_loginMethod", "ComboBox", "RMS")
    safe_click(dlg, auto_id="btn_Submit", control_type="Button")

    handle_popup(app, expected_substring="login to test/mock environment", auto_id_to_click="6", timeout=10)

    main_win = app.window(title_re=".*NCDEX RISK MANAGEMENT SYSTEM.*")
    main_win.wait("visible", timeout=40)
    time.sleep(15)
    handle_post_login_popups(app, main_win)
    return main_win

def close_rms_if_running():
    for proc in psutil.process_iter(['name']):
        try:
            if proc.info['name'] and "RMS FE.exe" in proc.info['name']:
                logger.info("Closing existing RMS FE.exe process...")
                proc.terminate()
                try:
                    proc.wait(timeout=10)
                except psutil.TimeoutExpired:
                    proc.kill()
        except Exception:
            pass

# ------------------- Workflow Runner -------------------
def run_workflow_for_user(username, password, is_rash1=False, start_time_value=None):
    close_rms_if_running()
    logger.info(f"Starting RMS for user: {username}")
    app = Application(backend="uia").start(
        r"D:\Program Files (x86)\NCCL Ltd\RMSSetup\RMS FE.exe"
    )
    main_win = login_user(app, username, password)
    click_rms_configuration_and_peak_margin(main_win)

    if not is_rash1:
        start_time = handle_peak_margin_add(app, main_win)
    else:
        if not start_time_value:
            raise ValueError("start_time_value is required for rash1 run")
        handle_peak_margin_reject_for_rash1(app, main_win, start_time_value)
        start_time = None

    safe_click(main_win, title="Exit", control_type="MenuItem")
    handle_popup(app, auto_id_to_click="6", timeout=10)
    logger.info(f"Workflow completed for user: {username}")
    return start_time

# ------------------- Main -------------------
def main():
    try:
        start_time_value = run_workflow_for_user("QA1", "change@1212", is_rash1=False)
        run_workflow_for_user("rash1", "change@1212", is_rash1=True, start_time_value=start_time_value)
        logger.info("Automation script completed successfully for both users.")
    except Exception as e:
        logger.exception(f"Automation failed: {e}")

if __name__ == "__main__":
    main()
